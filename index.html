<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>週表示 空き時間選択 & マージ (Modern)</title>
    <style>
        /* --- Base Styles & Variables --- */
        :root {
            --primary-color: #007bff; /* アクセントカラー (ブルー系) */
            --primary-light: #e6f2ff;
            --primary-dark: #0056b3;
            --select-bg: rgba(0, 123, 255, 0.3); /* ドラッグ中の背景 */
            --selected-bg: #007bff; /* 選択確定後の背景 */
            --selected-text: #ffffff; /* 選択確定後の文字色 */
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #6c757d;
            --text-color: #212529;
            --border-color: #ced4da;
            --body-bg: #ffffff;
            --slot-height: 35px; /* スロットの高さ */
            --header-height: 30px; /* ヘッダーの高さ */
            --time-label-width: 50px; /* 時間ラベルの幅 */
            --border-radius: 0.3rem; /* 角丸 */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji",
                "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: var(--body-bg);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.5;
        }

        h1, h2, h3 {
            color: var(--text-color);
            margin-top: 1.5em;
            margin-bottom: 0.8em;
        }
        h1 { text-align: center; }

        /* --- Navigation --- */
        .navigation {
            margin-bottom: 25px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* 小画面で折り返し */
            justify-content: center;
        }

        /* --- Buttons --- */
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.95rem;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover {
            background-color: var(--primary-dark);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        button:active {
            background-color: var(--primary-dark);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        /* Copyボタンは少し目立たなく */
        #copy-button {
            background-color: var(--dark-gray);
        }
         #copy-button:hover {
             background-color: #5a6268;
         }


        /* --- Calendar --- */
        .calendar-container {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: #fff;
            user-select: none;
            -webkit-user-select: none;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow-x: auto; /* 横スクロール可能に */
            max-width: 100%; /* 親要素に収める */
        }

        .time-labels {
            flex-shrink: 0; /* 時間ラベルは縮まない */
            width: var(--time-label-width);
            text-align: right;
            font-size: 11px;
            color: var(--dark-gray);
            padding-right: 5px;
            border-right: 1px solid var(--border-color);
        }
        .time-labels div {
            height: var(--slot-height);
            border-top: 1px solid var(--medium-gray); /* 時間ごとの線 */
            box-sizing: border-box;
            padding-top: 3px;
             display: flex;
             justify-content: flex-end;
             align-items: flex-start;
        }
         .time-labels div.label-hour { /* 00分のラベル */
             font-weight: 500;
         }
         .time-labels div:first-child { /* ヘッダー高さ合わせ */
             border-top: none;
             height: var(--header-height);
         }
         .time-labels div:not(.label-hour):not(:first-child) { /* 30分などの中間スロット */
             border-top-style: dotted;
             border-top-color: #e9ecef;
         }


        #calendar-grid {
             display: flex; /* Day columns horizontally */
             flex-grow: 1; /* 利用可能なスペースを埋める */
         }

        .day-column {
            flex: 1 1 100px; /* 基本幅100px、伸縮可能 */
            min-width: 80px; /* 最小幅 */
            border-left: 1px solid var(--border-color);
        }
         .day-column:first-child {
             border-left: none;
         }

        .day-header {
            text-align: center;
            padding: 5px 2px;
            font-size: 12px;
            font-weight: 600;
            height: var(--header-height);
            border-bottom: 1px solid var(--border-color);
            background-color: var(--light-gray);
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .time-slot {
            height: var(--slot-height);
            border-top: 1px dotted var(--medium-gray); /* 30分ごとの線 */
            box-sizing: border-box;
            cursor: pointer;
            position: relative;
            transition: background-color 0.15s ease;
        }
         .time-slot.hour-line { /* 時間ごとの線 (00分) */
             border-top: 1px solid var(--border-color);
         }
         .day-column .time-slot:first-child { /* 各列の最初のスロットの上線 */
             border-top: none;
         }
        .time-slot:hover {
            background-color: rgba(0, 0, 0, 0.03); /* 軽いホバー色 */
        }

        /* --- Selection Styles --- */
        .time-slot.selecting {
            background-color: var(--select-bg);
            border-color: transparent; /* 選択中は境界線を消すことも */
        }
        .time-slot.selected {
            background-color: var(--selected-bg);
            border-color: var(--primary-dark); /* 選択境界色 */
            color: var(--selected-text); /* 必要なら文字色変更 */
        }
        /* 選択されているスロットのホバー */
         .time-slot.selected:hover {
             background-color: var(--primary-dark);
         }


        /* --- Output & Merge Areas --- */
        .section-container {
            width: 90%;
            max-width: 700px; /* 少し広げる */
            margin-top: 30px;
            background-color: #fff;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
        }
        .section-container h2 { margin-top: 0; }
        .section-container h3 { margin-top: 1.2em; margin-bottom: 0.5em; font-size: 1rem; color: var(--dark-gray); }

        textarea {
             width: 100%;
             height: 150px;
             margin-top: 5px;
             margin-bottom: 15px;
             padding: 10px;
             box-sizing: border-box;
             border: 1px solid var(--border-color);
             border-radius: var(--border-radius);
             font-family: monospace;
             font-size: 0.9rem;
             resize: vertical; /* 縦方向リサイズ可 */
        }
         textarea:focus {
             border-color: var(--primary-color);
             outline: none;
             box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
         }

        .result-area {
            white-space: pre-wrap;
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-top: 10px;
            min-height: 60px;
            background-color: var(--light-gray);
            border-radius: var(--border-radius);
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
         .section-container button {
             /* ボタンのスタイルは共通 */
             margin-top: 10px;
         }
         #merge-button { /* マージボタンは目立たせる */
             background-color: #28a745; /* 緑系 */
         }
         #merge-button:hover {
             background-color: #218838;
         }

        hr {
            border: none;
            border-top: 1px solid var(--medium-gray);
            width: 90%;
            margin-top: 40px;
            margin-bottom: 40px;
        }

         /* --- Responsive Adjustments (Basic) --- */
         @media (max-width: 768px) {
             body { padding: 10px; }
             h1 { font-size: 1.5rem; }
             .section-container { width: 95%; padding: 15px; }
             .day-header { font-size: 11px; padding: 5px 1px; }
             .time-labels { width: 40px; font-size: 10px; }
             button { padding: 6px 12px; font-size: 0.9rem; }
         }
         @media (max-width: 480px) {
              .navigation { gap: 5px; }
              button { padding: 5px 8px; font-size: 0.85rem; }
              .day-header { font-size: 10px; height: 35px; white-space: normal; } /* 日付が長い場合折り返し */
              .time-labels { display: none; } /* 狭すぎたら時間ラベル非表示も検討 */
              .calendar-container { border: none; box-shadow: none; }
              .day-column { min-width: 50px; }
         }

    </style>
</head>
<body>

    <h1>スケジュール調整ツール</h1>

    <div class="navigation">
        <button id="prev-week">先週</button>
        <button id="current-week">今週</button>
        <button id="next-week">来週</button>
    </div>

    <div class="calendar-container">
        <div class="time-labels" id="time-labels"></div>
        <div id="calendar-grid"></div> </div>

    <div class="section-container" id="output-container">
        <h2>あなたの空き日程</h2>
        <div id="output" class="result-area">選択するか、下のエリアからペーストしてください</div>
        <button id="copy-button">クリップボードにコピー</button>
    </div>

    <hr>

    <div class="section-container" id="merge-container">
        <h2>日程マージ</h2>
        <p>各参加者の空き日程 (上記形式) を貼り付けてください。<br>
           参加者ごとに <code>---</code> (ハイフン3つ) の行で区切ってください。</p>
        <textarea id="merge-input" placeholder="参加者1の日程...
4/11 10:00-19:00
4/11 21:00-22:00
---
参加者2の日程...
4/11 14:00-22:00
4/13 11:00-13:00
---
参加者3の日程..."></textarea>
        <button id="merge-button">全員の重複時間を検索</button>
        <h3>全員が共通して空いている時間:</h3>
        <div id="merge-result" class="result-area"></div>
    </div>

    <script>
        // --- 要素取得 (変更なし) ---
        const calendarGrid = document.getElementById('calendar-grid');
        const timeLabels = document.getElementById('time-labels');
        const outputDiv = document.getElementById('output');
        const copyButton = document.getElementById('copy-button');
        const prevWeekButton = document.getElementById('prev-week');
        const currentWeekButton = document.getElementById('current-week');
        const nextWeekButton = document.getElementById('next-week');
        const mergeInput = document.getElementById('merge-input');
        const mergeButton = document.getElementById('merge-button');
        const mergeResultDiv = document.getElementById('merge-result');

        // --- 定数・状態変数 (変更なし) ---
        const hours = 24;
        const slotDurationMinutes = 30; // 30分単位
        const slotsPerHour = 60 / slotDurationMinutes;
        const daysToShow = 7;
        let weekDates = [];
        let isDragging = false;
        let startSlot = null;
        let selectedSlots = new Set();
        let referenceDateForWeek = new Date(); // Start with current date

        // --- 初期化 (変更なし) ---
        function initialize() {
            createTimeLabels();
            renderCalendarForReferenceDate();
            addEventListeners();
            addNavigationListeners();
            addMergeListeners();
            updateOutput(); // Initial output update
        }

        // --- 週移動・カレンダー描画関連 ---
        function renderCalendarForReferenceDate() {
            setupWeekDates();
            createCalendarGrid(); // Re-render grid which checks selectedSlots
        }

        function setupWeekDates() {
            const refDate = new Date(referenceDateForWeek);
            const currentDayOfWeek = refDate.getDay(); // 0 (Sun) - 6 (Sat)
            const diffToMonday = currentDayOfWeek === 0 ? -6 : 1 - currentDayOfWeek;
            const monday = new Date(refDate);
            monday.setDate(refDate.getDate() + diffToMonday);
            monday.setHours(0, 0, 0, 0); // Normalize to start of the day

            weekDates = [];
            for (let i = 0; i < daysToShow; i++) {
                const date = new Date(monday);
                date.setDate(monday.getDate() + i);
                weekDates.push(date);
            }
        }

        function formatDate(date) {
            const m = (date.getMonth() + 1).toString().padStart(2, '0');
            const d = date.getDate().toString().padStart(2, '0');
            return `${m}/${d}`;
        }

        function formatTime(hour, minute) {
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        }

        function createTimeLabels() {
            timeLabels.innerHTML = ''; // Clear previous labels
            const headerSpacer = document.createElement('div'); // Spacer for day header height
            timeLabels.appendChild(headerSpacer);

            for (let hour = 0; hour < hours; hour++) {
                 // Main hour label
                const hourLabelDiv = document.createElement('div');
                hourLabelDiv.classList.add('label-hour'); // Style hour marks differently
                hourLabelDiv.textContent = `${hour}:00`;
                timeLabels.appendChild(hourLabelDiv);

                // Intermediate slots (e.g., for :30)
                for (let i = 1; i < slotsPerHour; i++) {
                    const slotSpacer = document.createElement('div');
                    // Optionally add ':30' label here if needed
                    timeLabels.appendChild(slotSpacer);
                }
            }
        }


        function createCalendarGrid() {
            calendarGrid.innerHTML = ''; // Clear previous grid
            weekDates.forEach((date, dayIndex) => {
                const dayColumn = document.createElement('div');
                dayColumn.classList.add('day-column');
                dayColumn.dataset.dayIndex = dayIndex;

                const dayHeader = document.createElement('div');
                dayHeader.classList.add('day-header');
                 // Include year in header for clarity if spanning years? Optional.
                dayHeader.textContent = `${formatDate(date)} (${['日','月','火','水','木','金','土'][date.getDay()]})`;
                dayColumn.appendChild(dayHeader);

                for (let hour = 0; hour < hours; hour++) {
                    for (let minuteStep = 0; minuteStep < slotsPerHour; minuteStep++) {
                        const minute = minuteStep * slotDurationMinutes;
                        const timeSlot = document.createElement('div');
                        timeSlot.classList.add('time-slot');

                         // Add class for hour line styling
                        if (minute === 0) {
                             timeSlot.classList.add('hour-line');
                        }

                        const slotIndex = hour * slotsPerHour + minuteStep;
                        const slotDateStr = formatDate(date); // Use date for this specific slot
                        const slotId = `${slotDateStr}_${slotIndex}`; // Unique ID: "MM/DD_index"
                        timeSlot.dataset.slotId = slotId;
                        timeSlot.dataset.date = slotDateStr; // Store MM/DD
                        timeSlot.dataset.hour = hour;
                        timeSlot.dataset.minute = minute;
                        timeSlot.dataset.dayIndex = dayIndex; // Column index
                        timeSlot.dataset.slotIndex = slotIndex; // Row index (within day)

                        // Restore selection state
                        if (selectedSlots.has(slotId)) {
                            timeSlot.classList.add('selected');
                        }

                        dayColumn.appendChild(timeSlot);
                    }
                }
                calendarGrid.appendChild(dayColumn);
            });
        }

        // --- イベント処理 (Event Handling) ---
        function addEventListeners() {
            calendarGrid.addEventListener('mousedown', handleMouseDown);
            calendarGrid.addEventListener('mousemove', handleMouseMove);
            // Mouse up anywhere on the document should stop dragging
            document.addEventListener('mouseup', handleMouseUp);
        }

        function addNavigationListeners() {
            prevWeekButton.addEventListener('click', () => {
                referenceDateForWeek.setDate(referenceDateForWeek.getDate() - 7);
                renderCalendarForReferenceDate();
            });
            currentWeekButton.addEventListener('click', () => {
                referenceDateForWeek = new Date(); // Reset to today
                renderCalendarForReferenceDate();
            });
            nextWeekButton.addEventListener('click', () => {
                referenceDateForWeek.setDate(referenceDateForWeek.getDate() + 7);
                renderCalendarForReferenceDate();
            });
        }

        function handleMouseDown(event) {
            // Only start dragging if a time slot was clicked
            if (event.target.classList.contains('time-slot')) {
                isDragging = true;
                startSlot = event.target;
                // Clear any previous 'selecting' highlights
                clearSelectingHighlight();
                // Mark the starting slot as 'selecting'
                toggleSelecting(startSlot);
                event.preventDefault(); // Prevent text selection during drag
            }
        }

        function handleMouseMove(event) {
            if (!isDragging || !startSlot) return;

            // If moving over a valid time slot
            if (event.target.classList.contains('time-slot')) {
                // Clear previous 'selecting' highlights and highlight the new range
                clearSelectingHighlight();
                highlightRange(startSlot, event.target);
            }
            event.preventDefault();
        }

        function handleMouseUp(event) {
            if (!isDragging) return; // Only act if we were dragging

            isDragging = false;
            const endSlot = event.target.classList.contains('time-slot') ? event.target : null; // Check if mouse up happened over a slot

            // Apply the selection based on the drag range
            applySelection(startSlot, endSlot);

            // Clean up temporary 'selecting' highlights
            clearSelectingHighlight();
            // Update the output text area
            updateOutput();
            startSlot = null; // Reset starting slot
        }

        // --- 選択ロジック (Selection Logic) ---
         function toggleSelecting(slot) {
             // Always add 'selecting' class when starting drag
             slot.classList.add('selecting');
         }

         function clearSelectingHighlight() {
             document.querySelectorAll('.time-slot.selecting').forEach(s => s.classList.remove('selecting'));
         }

         function highlightRange(start, end) {
             if (!start || !end) return; // Need both start and end

             // Get coordinates (day index, slot index)
             const startDay = parseInt(start.dataset.dayIndex);
             const endDay = parseInt(end.dataset.dayIndex);
             const startIndex = parseInt(start.dataset.slotIndex);
             const endIndex = parseInt(end.dataset.slotIndex);

             // Determine the rectangle bounds for highlighting
             const minDay = Math.min(startDay, endDay);
             const maxDay = Math.max(startDay, endDay);
             const minIndex = Math.min(startIndex, endIndex);
             const maxIndex = Math.max(startIndex, endIndex);

             // Iterate through the rectangle and add 'selecting' class
             for (let d = minDay; d <= maxDay; d++) {
                 // Get the column element for the day
                 // Note: calendarGrid's children are the day columns directly now
                 const column = calendarGrid.children[d];
                  if (!column) continue; // Safety check
                 // Find slots within the time range in this column
                 for (let i = minIndex; i <= maxIndex; i++) {
                     // Find the specific slot using data attributes
                     const slot = column.querySelector(`[data-slot-index='${i}']`);
                     if (slot) {
                         slot.classList.add('selecting');
                     }
                 }
             }
         }

        function applySelection(start, end) {
            if (!start) return; // Must have a starting point

            // Determine the range of slots affected by the drag
             const slotsToToggle = [];
             const startDay = parseInt(start.dataset.dayIndex);
             // If mouseup outside grid, use start slot as end
             const endDay = end ? parseInt(end.dataset.dayIndex) : startDay;
             const startIndex = parseInt(start.dataset.slotIndex);
             const endIndex = end ? parseInt(end.dataset.slotIndex) : startIndex;

             const minDay = Math.min(startDay, endDay);
             const maxDay = Math.max(startDay, endDay);
             const minIndex = Math.min(startIndex, endIndex);
             const maxIndex = Math.max(startIndex, endIndex);

             for (let d = minDay; d <= maxDay; d++) {
                 const column = calendarGrid.children[d];
                  if (!column) continue;
                 for (let i = minIndex; i <= maxIndex; i++) {
                     const slot = column.querySelector(`[data-slot-index='${i}']`);
                     if (slot) {
                         slotsToToggle.push(slot);
                     }
                 }
             }

            // Determine if we are selecting or deselecting based on the start slot's state
            const shouldSelect = !start.classList.contains('selected');

            // Apply the change (select or deselect) to all affected slots
            slotsToToggle.forEach(slot => {
                const slotId = slot.dataset.slotId; // Get the unique "MM/DD_index" ID
                if (shouldSelect) {
                    slot.classList.add('selected');
                    selectedSlots.add(slotId); // Add ID to our Set
                } else {
                    slot.classList.remove('selected');
                    selectedSlots.delete(slotId); // Remove ID from our Set
                }
            });
        }

        // --- 出力生成 (Output Generation) ---
        function updateOutput() {
            const lines = [];
            if (selectedSlots.size === 0) {
                outputDiv.textContent = 'カレンダーで空き時間を選択してください'; // More descriptive
                return;
            }

            // Parse selected slot IDs ("MM/DD_index") into structured data and sort
            const sortedSlots = Array.from(selectedSlots)
                .map(slotId => {
                    const [dateStr, indexStr] = slotId.split('_');
                    const index = parseInt(indexStr);
                    const hour = Math.floor(index / slotsPerHour);
                    const minute = (index % slotsPerHour) * slotDurationMinutes;
                    const [m, d] = dateStr.split('/').map(Number);

                    // Attempt to get the correct year for the Date object
                    let year = new Date().getFullYear(); // Default to current year
                    // Try to find the date in the currently displayed weekDates for a more accurate year
                    const matchingDate = weekDates.find(wd => formatDate(wd) === dateStr);
                    if (matchingDate) {
                        year = matchingDate.getFullYear();
                    } // If not found (e.g., selection from a previous week), uses current year (potential issue on year boundaries)

                    const startDateTime = new Date(year, m - 1, d, hour, minute); // month is 0-indexed
                    // Calculate end time based on duration
                    const endDateTime = new Date(startDateTime.getTime() + slotDurationMinutes * 60000);

                     // Return null for invalid dates to filter out later
                     if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
                         console.warn(`Invalid date created for slotId: ${slotId}`);
                         return null;
                     }

                    return { dateStr, index, startDateTime, endDateTime };
                })
                 .filter(slot => slot !== null) // Remove any invalid date entries
                .sort((a, b) => a.startDateTime - b.startDateTime); // Sort chronologically

            if (sortedSlots.length === 0) {
                outputDiv.textContent = '有効な時間が選択されていません';
                return;
            }

            // Merge contiguous slots into blocks
            let currentBlock = null;
            for (const slot of sortedSlots) {
                if (currentBlock === null) {
                    // Start the first block
                    currentBlock = { start: slot.startDateTime, end: slot.endDateTime };
                } else {
                    // Check if current slot immediately follows the previous block
                    if (currentBlock.end.getTime() === slot.startDateTime.getTime()) {
                        // Extend the current block
                        currentBlock.end = slot.endDateTime;
                    } else {
                        // Discontinuity: finalize the previous block and start a new one
                        lines.push(formatBlock(currentBlock));
                        currentBlock = { start: slot.startDateTime, end: slot.endDateTime };
                    }
                }
            }
            // Add the last block if it exists
            if (currentBlock) {
                lines.push(formatBlock(currentBlock));
            }

            outputDiv.textContent = lines.join('\n');
        }

        // Format a time block {start: Date, end: Date} into "MM/DD HH:MM-HH:MM"
        function formatBlock(block) {
             const startDateStr = formatDate(block.start);
             const startTimeStr = formatTime(block.start.getHours(), block.start.getMinutes());
             // Handle midnight correctly (show 24:00 if end is exactly midnight next day?) - simpler: show 00:00 of next day if needed
             const endHour = block.end.getHours();
             const endMinute = block.end.getMinutes();
             let endTimeStr = formatTime(endHour, endMinute);

             // Special case: If end time is 00:00, maybe show 24:00 of the *previous* day for clarity?
             // Example: 23:30-00:00 (next day) could be shown as 23:30-24:00
             const startDay = block.start.getDate();
             const endDay = block.end.getDate();
             if (endHour === 0 && endMinute === 0 && endDay !== startDay) {
                  // Check if it's exactly one day difference. If so, consider showing 24:00
                  // This adds complexity, sticking to 00:00 for now.
             }

             // If block spans across midnight, indicate the end date? Optional.
             // const endDateStr = formatDate(block.end);
             // if (startDateStr !== endDateStr) {
             //    return `${startDateStr} ${startTimeStr} - ${endDateStr} ${endTimeStr}`;
             // }

             return `${startDateStr} ${startTimeStr}-${endTimeStr}`;
        }

        // --- クリップボードコピー (Clipboard Copy) ---
        copyButton.addEventListener('click', () => {
            const textToCopy = outputDiv.textContent;
            if (textToCopy && !textToCopy.startsWith('カレンダーで') && !textToCopy.startsWith('有効な時間')) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        // Optional: Show temporary success message
                        const originalText = copyButton.textContent;
                        copyButton.textContent = 'コピー完了!';
                        copyButton.style.backgroundColor = '#28a745'; // Success green
                        setTimeout(() => {
                             copyButton.textContent = originalText;
                             // ↓↓↓ 修正後 ↓↓↓
                             copyButton.style.backgroundColor = 'var(--dark-gray)'; // 文字列として指定
                         }, 1500);
                    })
                    .catch(err => {
                        console.error('コピー失敗:', err);
                        alert('クリップボードへのコピーに失敗しました。');
                    });
            } else {
                alert('コピーする日程がありません。');
            }
        });

        // --- マージ機能 (Merge Functionality) ---
        function addMergeListeners() {
            mergeButton.addEventListener('click', handleMerge);
        }

        function handleMerge() {
            const inputText = mergeInput.value.trim();
            mergeResultDiv.textContent = ''; // Clear previous results
            if (!inputText) {
                mergeResultDiv.textContent = "比較する日程をテキストエリアに入力してください。";
                return;
            }

            try {
                const participantsIntervals = parseMergeInput(inputText);

                if (participantsIntervals.length === 0) {
                     mergeResultDiv.textContent = "有効な日程データが見つかりませんでした。参加者ごとに '---' で区切られているか確認してください。";
                     return;
                }
                 if (participantsIntervals.length === 1) {
                     mergeResultDiv.textContent = "少なくとも2人分の日程が必要です。参加者ごとに '---' で区切ってください。";
                     return; // Need at least two participants to compare
                 }
                 // Check if any participant has empty intervals after parsing
                 if (participantsIntervals.some(intervals => intervals.length === 0)) {
                     console.warn("一部の参加者の日程が空または解析不能でした。");
                     // Optionally inform the user, or proceed with those who have data.
                 }


                const overlaps = findOverlaps(participantsIntervals);
                displayMergeResult(overlaps);

            } catch (e) {
                console.error("マージ処理エラー:", e);
                mergeResultDiv.textContent = `エラーが発生しました。\n${e.message}\n入力形式 (MM/DD HH:MM-HH:MM と区切り文字 ---) を確認してください。`;
            }
        }

        function parseMergeInput(text) {
            // Split by '---' separator line
             // Handles various line endings (\n, \r\n) around the separator
            const participantsData = text.split(/^\s*---\s*$/m);
            const allIntervals = [];

            // Use the year from the currently viewed week for consistency
            const currentYear = referenceDateForWeek.getFullYear();

            for (const participantText of participantsData) {
                const lines = participantText.trim().split('\n');
                const participantIntervals = [];
                // Regex to capture MM/DD HH:MM-HH:MM format
                const lineRegex = /(\d{1,2}\/\d{1,2})\s+(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})/;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    // Ignore empty lines or lines likely containing comments/headers
                    if (!trimmedLine || trimmedLine.startsWith('#') || trimmedLine.startsWith('//') || trimmedLine.startsWith('参加者')) continue;

                    const match = trimmedLine.match(lineRegex);
                    if (match) {
                        const dateStr = match[1]; // "MM/DD"
                        const startTimeStr = match[2]; // "HH:MM"
                        const endTimeStr = match[3]; // "HH:MM"

                        const [month, day] = dateStr.split('/').map(Number);
                        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                        const [endHour, endMinute] = endTimeStr.split(':').map(Number);

                        // Validate parsed numbers before creating Date
                        if ([month, day, startHour, startMinute, endHour, endMinute].some(isNaN)) {
                             console.warn("数値への変換に失敗:", trimmedLine);
                             continue;
                         }

                        // Create Date objects using the determined year
                        // Note: month is 0-indexed for Date constructor
                        const startDate = new Date(currentYear, month - 1, day, startHour, startMinute);
                        let endDate = new Date(currentYear, month - 1, day, endHour, endMinute);

                        // Handle overnight times (e.g., 22:00-02:00) - basic check
                        if (endDate <= startDate) {
                             // Assumes it crosses midnight into the next day
                             endDate.setDate(endDate.getDate() + 1);
                         }

                        // Final check for invalid dates (e.g., Feb 30th)
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                            console.warn("無効な日付オブジェクト:", trimmedLine, "->", startDate, endDate);
                            continue; // Skip this invalid entry
                        }

                        participantIntervals.push({ start: startDate, end: endDate });
                    } else if (trimmedLine) {
                        // Warn if a non-empty line didn't match the expected format
                        console.warn("解析できない行 (無視します):", trimmedLine);
                    }
                }
                 // Only add participant if they have valid intervals parsed
                if (participantIntervals.length > 0) {
                    allIntervals.push(participantIntervals);
                }
            }
            return allIntervals; // Array of arrays: [[p1_intervals], [p2_intervals], ...]
        }


        function findOverlaps(participantsIntervals) {
            const numParticipants = participantsIntervals.length;
            if (numParticipants < 2) return []; // Cannot find overlap with less than 2

            const events = [];
            // Create start and end event points for all intervals
            participantsIntervals.forEach(intervals => {
                intervals.forEach(interval => {
                    if (interval.end > interval.start) { // Only process valid intervals
                        events.push({ time: interval.start, type: 'start' });
                        events.push({ time: interval.end, type: 'end' });
                    }
                });
            });

            // Sort events: time ascending, then 'start' before 'end' for same time
            events.sort((a, b) => {
                const timeDiff = a.time.getTime() - b.time.getTime();
                if (timeDiff !== 0) return timeDiff;
                // If times are equal, 'start' comes first (-1), 'end' comes second (1)
                return a.type === 'start' ? -1 : 1;
            });

            const commonIntervals = [];
            let overlapCount = 0;
            let overlapStartTime = null;

            for (let i = 0; i < events.length; i++) {
                const event = events[i];
                const currentTime = event.time;
                let prevOverlapCount = overlapCount;

                // Update count based on event type
                if (event.type === 'start') {
                    overlapCount++;
                } else { // 'end'
                    overlapCount--;
                }

                // Check for state changes *after* processing the event at currentTime
                // BUT, need to consider multiple events at the *exact same time*

                 // Look ahead: process all events at the exact same time together
                 let nextEventIndex = i + 1;
                 while (nextEventIndex < events.length && events[nextEventIndex].time.getTime() === currentTime.getTime()) {
                     const nextEvent = events[nextEventIndex];
                     if (nextEvent.type === 'start') {
                         overlapCount++;
                     } else {
                         overlapCount--;
                     }
                     i++; // Consume this event as well
                     nextEventIndex++;
                 }


                // Now evaluate the state change after processing all events at currentTime
                // Did an overlap start? (count reached N, was less than N before this time)
                 if (overlapCount === numParticipants && prevOverlapCount < numParticipants) {
                     overlapStartTime = currentTime;
                 }
                 // Did an overlap end? (count is now less than N, was N before this time)
                 else if (overlapCount < numParticipants && prevOverlapCount === numParticipants) {
                     // Record the interval if start time is valid and end>start
                     if (overlapStartTime !== null && currentTime > overlapStartTime) {
                         commonIntervals.push({ start: overlapStartTime, end: currentTime });
                     }
                     overlapStartTime = null; // Reset start time
                 }

                 prevOverlapCount = overlapCount; // Update prev count for the next distinct time
            }

            return commonIntervals;
        }


        function displayMergeResult(overlaps) {
            if (!overlaps || overlaps.length === 0) {
                mergeResultDiv.textContent = "全員が共通して空いている時間はありませんでした。";
                return;
            }
             // Merge adjacent/overlapping result blocks for cleaner output
             const mergedOverlaps = [];
             if (overlaps.length > 0) {
                 // Sort just in case (though findOverlaps should produce sorted output)
                 overlaps.sort((a, b) => a.start - b.start);
                 let currentMerged = { ...overlaps[0] }; // Copy first block

                 for (let i = 1; i < overlaps.length; i++) {
                     const nextBlock = overlaps[i];
                     // If next block starts exactly when current ends, merge
                     if (nextBlock.start.getTime() === currentMerged.end.getTime()) {
                         currentMerged.end = nextBlock.end;
                     } else {
                         // Discontinuity, push the merged block and start a new one
                         mergedOverlaps.push(currentMerged);
                         currentMerged = { ...nextBlock };
                     }
                 }
                 mergedOverlaps.push(currentMerged); // Push the last merged block
             }


            const lines = mergedOverlaps.map(block => formatBlock(block));
            mergeResultDiv.textContent = lines.join('\n');
        }


        // --- 実行 (Run) ---
        initialize();

    </script>

</body>
</html>
