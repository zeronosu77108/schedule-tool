<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>週表示 空き時間選択 & マージ (Modern / Custom)</title> 
    <style>
        /* --- Base Styles & Variables --- */
        :root {
            --primary-color: #007bff;
            --primary-light: #e6f2ff;
            --primary-dark: #0056b3;
            --select-bg: rgba(0, 123, 255, 0.3);
            --selected-bg: #007bff;
            --selected-text: #ffffff;
            --light-gray: #f8f9fa;
            --medium-gray: #dee2e6;
            --dark-gray: #6c757d;
            --text-color: #212529;
            --border-color: #ced4da;
            --body-bg: #ffffff;
            --slot-height: 35px;
            --header-height: 30px;
            --time-label-width: 50px;
            --border-radius: 0.3rem;
            /* Weekend background colors */
            --saturday-bg: #f0f8ff; /* AliceBlue - Light blue */
            --sunday-bg: #fff0f0;   /* LavenderBlush or Seashell - Light red */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji",
                "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: var(--body-bg);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.5;
        }

        h1, h2, h3 {
            color: var(--text-color);
            margin-top: 1.5em;
            margin-bottom: 0.8em;
        }
        h1 { text-align: center; }

        /* --- Navigation --- */
        .navigation {
            margin-bottom: 25px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* Wrap on small screens */
            justify-content: center;
        }

        /* --- Buttons --- */
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.95rem;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:hover {
            background-color: var(--primary-dark);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        button:active {
            background-color: var(--primary-dark);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        #copy-button {
            background-color: var(--dark-gray);
        }
         #copy-button:hover {
             background-color: #5a6268;
         }


        /* --- Calendar --- */
        .calendar-container {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: #fff; /* Needed for contained elements */
            user-select: none;
            -webkit-user-select: none;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow-x: auto; /* Enable horizontal scroll */
            max-width: 100%; /* Ensure it fits screen width */
            position: relative; /* Optional: establish stacking context */
        }

        .time-labels {
            flex-shrink: 0; /* Prevent shrinking */
            width: var(--time-label-width);
            text-align: right;
            font-size: 11px;
            color: var(--dark-gray);
            padding-right: 5px;
            border-right: 1px solid var(--border-color);
            background-color: var(--body-bg); /* Default background */
        }
        .time-labels div {
            height: var(--slot-height);
            border-top: 1px solid var(--medium-gray); /* Hour lines */
            box-sizing: border-box;
            padding-top: 3px;
             display: flex;
             justify-content: flex-end;
             align-items: flex-start;
        }
         .time-labels div.label-hour { /* 00 minute labels */
             font-weight: 500;
         }
         .time-labels div:first-child { /* Align with day header */
             border-top: none;
             height: var(--header-height);
         }
         .time-labels div:not(.label-hour):not(:first-child) { /* Intermediate slots */
             border-top-style: dotted;
             border-top-color: #e9ecef;
         }


        #calendar-grid {
             display: flex; /* Arrange day columns horizontally */
             flex-grow: 1; /* Take remaining space */
         }

        .day-column {
            flex: 1 1 100px; /* Base width 100px, allow shrink/grow */
            min-width: 80px; /* Minimum width before scroll */
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column; /* Stack header and slots vertically */
            background-color: #fff; /* Default background */
            transition: background-color 0.3s ease;
        }
        /* Weekend column styles */
        .day-column.saturday-column {
             background-color: var(--saturday-bg);
        }
        .day-column.sunday-column {
             background-color: var(--sunday-bg);
        }
        .day-column:first-child {
             border-left: none;
         }


        .day-header {
            text-align: center;
            padding: 5px 2px;
            font-size: 12px;
            font-weight: 600;
            height: var(--header-height);
            border-bottom: 1px solid var(--border-color);
            background-color: var(--light-gray);
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .time-slot {
             height: var(--slot-height);
             border-top: 1px dotted var(--medium-gray); /* 30min lines */
             box-sizing: border-box;
             cursor: pointer;
             position: relative;
             transition: background-color 0.15s ease;
             flex-shrink: 0; /* Prevent shrinking */
             background-color: transparent; /* Allow column background to show */
         }
         .time-slot.hour-line { /* 00 minute lines */
             border-top: 1px solid var(--border-color);
         }
         /* Removed rule for first time-slot border, as loops changed */

        .time-slot:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Slight hover effect */
        }

        /* --- Selection Styles --- */
        .time-slot.selecting {
            background-color: rgba(0, 123, 255, 0.4); /* Semi-transparent selecting */
            border-color: transparent;
        }
        .time-slot.selected {
            background-color: rgba(0, 123, 255, 0.85); /* Semi-transparent selected */
            /* background-color: var(--selected-bg); */ /* Use this for opaque */
            border-color: var(--primary-dark);
            /* color: var(--selected-text); */ /* Consider removing if background is transparent */
        }
         .time-slot.selected:hover {
             background-color: rgba(0, 86, 179, 0.9);
         }


        /* --- Output & Merge Areas --- */
        .section-container {
            width: 90%;
            max-width: 700px;
            margin-top: 30px;
            background-color: #fff;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
        }
        .section-container h2 { margin-top: 0; }
        .section-container h3 { margin-top: 1.2em; margin-bottom: 0.5em; font-size: 1rem; color: var(--dark-gray); }

        textarea {
             width: 100%;
             height: 150px;
             margin-top: 5px;
             margin-bottom: 15px;
             padding: 10px;
             box-sizing: border-box;
             border: 1px solid var(--border-color);
             border-radius: var(--border-radius);
             font-family: monospace;
             font-size: 0.9rem;
             resize: vertical;
        }
         textarea:focus {
             border-color: var(--primary-color);
             outline: none;
             box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
         }

        .result-area {
            white-space: pre-wrap;
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-top: 10px;
            min-height: 60px;
            background-color: var(--light-gray);
            border-radius: var(--border-radius);
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
         .section-container button {
             margin-top: 10px;
         }
         #merge-button {
             background-color: #28a745; /* Green */
         }
         #merge-button:hover {
             background-color: #218838;
         }

        hr {
            border: none;
            border-top: 1px solid var(--medium-gray);
            width: 90%;
            margin-top: 40px;
            margin-bottom: 40px;
        }

         /* --- Responsive Adjustments --- */
         @media (max-width: 768px) { /* Tablet and smaller */
             body { padding: 15px; }
             h1 { font-size: 1.6rem; }
             .section-container { width: 95%; padding: 15px; }
             button { padding: 7px 14px; font-size: 0.9rem; }
             .day-column { min-width: 70px; } /* Adjust min width */

             /* --- Make Time Labels Sticky --- */
             .time-labels {
                 position: -webkit-sticky; /* Safari */
                 position: sticky;
                 left: 0; /* Stick to the left edge */
                 z-index: 10; /* Ensure it's above the scrolling grid */
                 background-color: var(--body-bg); /* Match body background */
                 width: 45px; /* Fixed width for sticky labels */
                 font-size: 10px;
                 flex-shrink: 0;
                 border-right: 1px solid var(--border-color); /* Keep border */
             }
             /* Ensure parent container allows sticky positioning */
             .calendar-container {
                 position: relative; /* Can help with stacking context */
             }
             /* --- End Time Label Sticky --- */
         }

         @media (max-width: 480px) { /* Smartphone */
             body { padding: 10px; }
             h1 { font-size: 1.3rem; }
             .navigation { gap: 5px; margin-bottom: 20px; }
             button { padding: 6px 10px; font-size: 0.85rem; }

             .calendar-container {
                 border: 1px solid var(--border-color); /* Keep border */
                 box-shadow: none;
                 border-radius: 0;
                 margin-left: -10px; /* Use full width potentially */
                 margin-right: -10px;
             }
             .time-labels {
                 /* Sticky styles inherited from 768px */
                 width: 40px; /* Adjust width if needed */
             }

             .day-column {
                 min-width: 60px; /* Further reduce min column width */
                 border-left: 1px solid var(--medium-gray);
             }
             .day-column:first-child { border-left: none;}

             .day-header {
                 font-size: 10px;
                 height: auto; /* Allow wrapping */
                 min-height: var(--header-height);
                 white-space: normal; /* Allow wrapping */
                 padding: 4px 2px;
             }

            .section-container { width: 100%; padding: 15px; margin-top: 25px; border:none; box-shadow: none;}
            hr { width: 100%; margin: 30px 0;}
            textarea { height: 120px; }
         }

    </style>
</head>
<body>

    <h1>スケジュール調整ツール</h1>

    <div class="navigation">
        <button id="prev-week">先週</button>
        <button id="current-week">今週</button>
        <button id="next-week">来週</button>
    </div>

    <div class="calendar-container">
        <div class="time-labels" id="time-labels"></div>
        <div id="calendar-grid"></div> </div>

    <div class="section-container" id="output-container">
        <h2>あなたの空き日程</h2>
        <div id="output" class="result-area">選択するか、下のエリアからペーストしてください</div>
        <button id="copy-button">クリップボードにコピー</button>
    </div>

    <hr>

    <div class="section-container" id="merge-container">
        <h2>日程マージ</h2>
        <p>各参加者の空き日程 (上記形式) を貼り付けてください。<br>
           参加者ごとに <code>---</code> (ハイフン3つ) の行で区切ってください。</p>
        <textarea id="merge-input" placeholder="&#10;4/11 10:00-19:00&#10;---&#10;4/11 12:00-15:00"></textarea>
        <button id="merge-button">全員の重複時間を検索</button>
        <h3>全員が共通して空いている時間:</h3>
        <div id="merge-result" class="result-area"></div>
    </div>

    <script>
        // --- 要素取得 ---
        const calendarGrid = document.getElementById('calendar-grid');
        const timeLabels = document.getElementById('time-labels');
        const outputDiv = document.getElementById('output');
        const copyButton = document.getElementById('copy-button');
        const prevWeekButton = document.getElementById('prev-week');
        const currentWeekButton = document.getElementById('current-week');
        const nextWeekButton = document.getElementById('next-week');
        const mergeInput = document.getElementById('merge-input');
        const mergeButton = document.getElementById('merge-button');
        const mergeResultDiv = document.getElementById('merge-result');


        // --- 定数・状態変数 ---
        const hoursTotal = 24; // 1日の総時間数 (計算用) - これは使わないかも
        const slotDurationMinutes = 30; // 30分単位
        const slotsPerHour = 60 / slotDurationMinutes;
        const daysToShow = 7;
        // *** 追加: 表示時間帯 ***
        const displayStartHour = 6; // 表示開始時間 (6時)
        const displayEndHour = 24;  // 表示終了時間 (24時 = 23:59まで表示)

        let weekDates = [];
        let isDragging = false;
        let startSlot = null;
        let selectedSlots = new Set(); // 選択されたスロットID ("MM/DD_インデックス") を保持
        let referenceDateForWeek = new Date(); // Start with current date


        // --- 初期化 ---
        function initialize() {
            createTimeLabels(); // 時間ラベル生成
            renderCalendarForReferenceDate(); // 初期カレンダー描画
            addEventListeners(); // ドラッグ選択などのリスナー
            addNavigationListeners(); // 週移動ボタンのリスナー
            addMergeListeners(); // マージボタンのリスナー
            updateOutput(); // 初期出力表示 (空のはず)
        }

        // --- 週移動・カレンダー描画関連 ---
        function renderCalendarForReferenceDate() {
            setupWeekDates(); // 表示する週の日付を計算・設定
            createCalendarGrid(); // 新しい日付でカレンダーグリッドを再描画
        }

        function setupWeekDates() {
            const refDate = new Date(referenceDateForWeek);
            const currentDayOfWeek = refDate.getDay(); // 0 (Sun) - 6 (Sat)
            const diffToMonday = currentDayOfWeek === 0 ? -6 : 1 - currentDayOfWeek; // 月曜を週の開始とする
            const monday = new Date(refDate);
            monday.setDate(refDate.getDate() + diffToMonday);
            monday.setHours(0, 0, 0, 0); // 日付の変わり目を0時に正規化

            weekDates = [];
            for (let i = 0; i < daysToShow; i++) {
                const date = new Date(monday);
                date.setDate(monday.getDate() + i);
                weekDates.push(date);
            }
        }

        // --- 日付・時間フォーマット ---
        function formatDate(date) {
            // 無効な日付オブジェクトの場合、エラーを防ぐ
            if (!(date instanceof Date) || isNaN(date.getTime())) {
                return "??/??"; // または他のエラー表示
            }
            const m = (date.getMonth() + 1).toString().padStart(2, '0');
            const d = date.getDate().toString().padStart(2, '0');
            return `${m}/${d}`;
        }

        function formatTime(hour, minute) {
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        }

        // --- カレンダー要素生成 ---
        function createTimeLabels() {
            timeLabels.innerHTML = ''; // Clear previous labels
            const headerSpacer = document.createElement('div'); // Spacer for day header height
            timeLabels.appendChild(headerSpacer);

            // Loop through the hours to display
            for (let hour = displayStartHour; hour < displayEndHour; hour++) {
                // Main hour label (e.g., 6:00, 7:00)
                const hourLabelDiv = document.createElement('div');
                hourLabelDiv.classList.add('label-hour');
                hourLabelDiv.textContent = `${hour}:00`;
                timeLabels.appendChild(hourLabelDiv);

                // Intermediate slots (e.g., for 6:30, 7:30)
                for (let i = 1; i < slotsPerHour; i++) {
                    const slotSpacer = document.createElement('div');
                    // Optionally add ':30' text content here if needed
                    timeLabels.appendChild(slotSpacer);
                }
            }
        }

        function createCalendarGrid() {
            calendarGrid.innerHTML = ''; // Clear previous grid
            weekDates.forEach((date, dayIndex) => {
                const dayColumn = document.createElement('div');
                dayColumn.classList.add('day-column');
                dayColumn.dataset.dayIndex = dayIndex;

                // Add Saturday/Sunday classes
                const dayOfWeek = date.getDay(); // 0=Sun, 6=Sat
                if (dayOfWeek === 6) {
                    dayColumn.classList.add('saturday-column');
                } else if (dayOfWeek === 0) {
                    dayColumn.classList.add('sunday-column');
                }

                // Create Day Header
                const dayHeader = document.createElement('div');
                dayHeader.classList.add('day-header');
                dayHeader.textContent = `${formatDate(date)} (${['日','月','火','水','木','金','土'][dayOfWeek]})`;
                dayColumn.appendChild(dayHeader);

                // Create Time Slots for the display range
                for (let hour = displayStartHour; hour < displayEndHour; hour++) {
                    for (let minuteStep = 0; minuteStep < slotsPerHour; minuteStep++) {
                        const minute = minuteStep * slotDurationMinutes;
                        const timeSlot = document.createElement('div');
                        timeSlot.classList.add('time-slot');

                        // Add class for hour line styling (00 minutes)
                        if (minute === 0) {
                             timeSlot.classList.add('hour-line');
                        }

                        // Calculate slotIndex based on 0-23 hours for data consistency
                        const slotIndex = hour * slotsPerHour + minuteStep;
                        const slotDateStr = formatDate(date);
                        const slotId = `${slotDateStr}_${slotIndex}`; // Unique ID: "MM/DD_index" (0-based index)

                        // Set data attributes for interaction and styling
                        timeSlot.dataset.slotId = slotId;
                        timeSlot.dataset.date = slotDateStr; // MM/DD
                        timeSlot.dataset.hour = hour;      // Hour this slot represents (6-23)
                        timeSlot.dataset.minute = minute;    // Minute this slot represents (0, 30)
                        timeSlot.dataset.dayIndex = dayIndex;  // Column index (0-6)
                        timeSlot.dataset.slotIndex = slotIndex;// Absolute index (0-47 or similar, 0-based from midnight)

                        // Restore selection state if this slot ID is in the Set
                        if (selectedSlots.has(slotId)) {
                            timeSlot.classList.add('selected');
                        }

                        dayColumn.appendChild(timeSlot);
                    }
                }
                calendarGrid.appendChild(dayColumn);
            });
        }

        // --- イベント処理 (Event Handling) ---
        function addEventListeners() {
            calendarGrid.addEventListener('mousedown', handleMouseDown);
            calendarGrid.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp); // Listen on document for mouseup outside grid
        }

        function addNavigationListeners() {
            prevWeekButton.addEventListener('click', () => {
                referenceDateForWeek.setDate(referenceDateForWeek.getDate() - 7);
                renderCalendarForReferenceDate();
            });
            currentWeekButton.addEventListener('click', () => {
                referenceDateForWeek = new Date(); // Reset to today
                renderCalendarForReferenceDate();
            });
            nextWeekButton.addEventListener('click', () => {
                referenceDateForWeek.setDate(referenceDateForWeek.getDate() + 7);
                renderCalendarForReferenceDate();
            });
        }

        function handleMouseDown(event) {
            if (event.target.classList.contains('time-slot')) {
                isDragging = true;
                startSlot = event.target;
                clearSelectingHighlight();
                toggleSelecting(startSlot);
                event.preventDefault(); // Prevent default text selection behavior
            }
        }

        function handleMouseMove(event) {
            if (!isDragging || !startSlot) return;
            if (event.target.classList.contains('time-slot')) {
                clearSelectingHighlight(); // Clear previous highlights
                highlightRange(startSlot, event.target); // Highlight current range
            }
            event.preventDefault();
        }

        function handleMouseUp(event) {
            if (!isDragging) return;
            isDragging = false;
            const endSlot = event.target.classList.contains('time-slot') ? event.target : null;
            applySelection(startSlot, endSlot); // Apply selection changes
            clearSelectingHighlight(); // Remove temporary highlights
            updateOutput(); // Update the text output area
            startSlot = null; // Reset drag start
        }

        // --- 選択ロジック (Selection Logic) ---
         function toggleSelecting(slot) {
             slot.classList.add('selecting'); // Indicate visually during drag
         }

         function clearSelectingHighlight() {
             document.querySelectorAll('.time-slot.selecting').forEach(s => s.classList.remove('selecting'));
         }

         function highlightRange(start, end) {
             if (!start || !end) return;
             const startDay = parseInt(start.dataset.dayIndex);
             const endDay = parseInt(end.dataset.dayIndex);
             // Use the 0-based slotIndex for range calculation
             const startIndex = parseInt(start.dataset.slotIndex);
             const endIndex = parseInt(end.dataset.slotIndex);

             const minDay = Math.min(startDay, endDay);
             const maxDay = Math.max(startDay, endDay);
             const minIndex = Math.min(startIndex, endIndex);
             const maxIndex = Math.max(startIndex, endIndex);

             for (let d = minDay; d <= maxDay; d++) {
                 const column = calendarGrid.children[d];
                  if (!column) continue;
                 // Iterate only through the displayed slots if needed? No, use index.
                 for (let i = minIndex; i <= maxIndex; i++) {
                     // Check if this index corresponds to a displayed hour
                     const hourOfIndex = Math.floor(i / slotsPerHour);
                     if (hourOfIndex >= displayStartHour) {
                        const slot = column.querySelector(`[data-slot-index='${i}']`);
                        if (slot) {
                            slot.classList.add('selecting');
                        }
                     }
                 }
             }
         }

        function applySelection(start, end) {
            if (!start) return;
             const slotsToToggle = [];
             const startDay = parseInt(start.dataset.dayIndex);
             const endDay = end ? parseInt(end.dataset.dayIndex) : startDay;
             const startIndex = parseInt(start.dataset.slotIndex);
             const endIndex = end ? parseInt(end.dataset.slotIndex) : startIndex;

             const minDay = Math.min(startDay, endDay);
             const maxDay = Math.max(startDay, endDay);
             const minIndex = Math.min(startIndex, endIndex);
             const maxIndex = Math.max(startIndex, endIndex);

             for (let d = minDay; d <= maxDay; d++) {
                 const column = calendarGrid.children[d];
                  if (!column) continue;
                 for (let i = minIndex; i <= maxIndex; i++) {
                     // Apply only to displayed slots if needed? No, data is 0-based.
                     const hourOfIndex = Math.floor(i / slotsPerHour);
                     // We store based on 0-based index, so always find the element if it exists
                     // (it might not exist visually if before displayStartHour, but that's ok for data)
                      const slotElement = column.querySelector(`[data-slot-index='${i}']`);
                      // Only toggle visible elements visually, but update data for all
                      if (slotElement) { // Only push if the element exists in the DOM
                          slotsToToggle.push(slotElement);
                      }
                 }
             }

            // Determine action based on the starting slot's state
            const shouldSelect = !start.classList.contains('selected');

            // Apply state change to elements and update the data Set
            slotsToToggle.forEach(slot => {
                const slotId = slot.dataset.slotId; // Get the ID ("MM/DD_index")
                if (shouldSelect) {
                    slot.classList.add('selected');
                    selectedSlots.add(slotId); // Add to data Set
                } else {
                    slot.classList.remove('selected');
                    selectedSlots.delete(slotId); // Remove from data Set
                }
            });
             // Also need to update data Set for non-visible elements if drag spans them
             // Iterate through index range again, but only update Set
             for (let d = minDay; d <= maxDay; d++) {
                 for (let i = minIndex; i <= maxIndex; i++) {
                      const hourOfIndex = Math.floor(i / slotsPerHour);
                      // Find corresponding date string based on day index d
                      const currentDateStr = formatDate(weekDates[d]);
                      const slotId = `${currentDateStr}_${i}`;

                      // Check if this slot is NOT in the visible elements already processed
                      const elementExists = slotsToToggle.some(el => el.dataset.slotId === slotId);

                      if (!elementExists && hourOfIndex < displayStartHour) { // Only update data for hidden slots
                           if (shouldSelect) {
                               selectedSlots.add(slotId);
                           } else {
                               selectedSlots.delete(slotId);
                           }
                      }
                 }
             }
        }

        // --- 出力生成 (Output Generation) ---
        function updateOutput() {
            const lines = [];
            if (selectedSlots.size === 0) {
                outputDiv.textContent = 'カレンダーで空き時間を選択してください';
                return;
            }

            // Parse selected slot IDs ("MM/DD_index") into structured data and sort
            const sortedSlots = Array.from(selectedSlots)
                .map(slotId => {
                    const [dateStr, indexStr] = slotId.split('_');
                    if (!dateStr || !indexStr) return null; // Basic validation
                    const index = parseInt(indexStr);
                    if (isNaN(index)) return null; // Basic validation

                    const hour = Math.floor(index / slotsPerHour); // 0-23 hour
                    const minute = (index % slotsPerHour) * slotDurationMinutes; // 0, 30
                    const [m, d] = dateStr.split('/').map(Number);

                    if (isNaN(m) || isNaN(d)) return null; // Basic validation

                    let year = new Date().getFullYear(); // Default year
                    // Find matching date in weekDates to get correct year
                    const matchingDate = weekDates.find(wd => formatDate(wd) === dateStr);
                    if (matchingDate) {
                        year = matchingDate.getFullYear();
                    }

                    const startDateTime = new Date(year, m - 1, d, hour, minute);
                    const endDateTime = new Date(startDateTime.getTime() + slotDurationMinutes * 60000);

                     if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
                         console.warn(`Invalid date created for slotId: ${slotId}`);
                         return null; // Invalid date parsed
                     }
                    // Filter out slots before display start time IF desired for output
                    // if (hour < displayStartHour) return null; // Uncomment to hide early hours in output

                    return { dateStr, index, startDateTime, endDateTime };
                })
                 .filter(slot => slot !== null) // Remove nulls from parsing errors or filters
                .sort((a, b) => a.startDateTime - b.startDateTime); // Sort chronologically

            if (sortedSlots.length === 0) {
                outputDiv.textContent = '有効な時間が選択されていません';
                return;
            }

            // Merge contiguous slots into blocks
            let currentBlock = null;
            for (const slot of sortedSlots) {
                if (currentBlock === null) {
                    currentBlock = { start: slot.startDateTime, end: slot.endDateTime };
                } else {
                    if (currentBlock.end.getTime() === slot.startDateTime.getTime()) {
                        currentBlock.end = slot.endDateTime; // Extend block
                    } else {
                        lines.push(formatBlock(currentBlock)); // Finalize previous block
                        currentBlock = { start: slot.startDateTime, end: slot.endDateTime }; // Start new block
                    }
                }
            }
            if (currentBlock) {
                lines.push(formatBlock(currentBlock)); // Add the last block
            }

            outputDiv.textContent = lines.join('\n');
        }

        function formatBlock(block) {
             const startDateStr = formatDate(block.start);
             const startTimeStr = formatTime(block.start.getHours(), block.start.getMinutes());
             const endTimeStr = formatTime(block.end.getHours(), block.end.getMinutes());
             return `${startDateStr} ${startTimeStr}-${endTimeStr}`;
        }

        // --- クリップボードコピー ---
        copyButton.addEventListener('click', () => {
            const textToCopy = outputDiv.textContent;
            if (textToCopy && !textToCopy.startsWith('カレンダーで') && !textToCopy.startsWith('有効な時間')) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        const originalText = copyButton.textContent;
                        copyButton.textContent = 'コピー完了!';
                        copyButton.style.backgroundColor = '#28a745'; // Success green
                        setTimeout(() => {
                             copyButton.textContent = originalText;
                             copyButton.style.backgroundColor = 'var(--dark-gray)'; // Revert style using string
                         }, 1500);
                    })
                    .catch(err => {
                        console.error('コピー失敗:', err);
                        alert('クリップボードへのコピーに失敗しました。');
                    });
            } else {
                alert('コピーする日程がありません。');
            }
        });

        // --- マージ機能 ---
        function addMergeListeners() {
            mergeButton.addEventListener('click', handleMerge);
        }

        function handleMerge() {
            const inputText = mergeInput.value.trim();
            mergeResultDiv.textContent = '';
            if (!inputText) {
                mergeResultDiv.textContent = "比較する日程をテキストエリアに入力してください。";
                return;
            }
            try {
                const participantsIntervals = parseMergeInput(inputText);
                if (participantsIntervals.length < 2) { // Also handles case where parsing failed and returned empty array effectively
                     mergeResultDiv.textContent = "比較するには少なくとも2人分の日程が必要です。参加者ごとに '---' で区切ってください。";
                     return;
                 }
                const overlaps = findOverlaps(participantsIntervals);
                displayMergeResult(overlaps);
            } catch (e) {
                console.error("マージ処理エラー:", e);
                mergeResultDiv.textContent = `エラーが発生しました。\n${e.message}\n入力形式 (MM/DD HH:MM-HH:MM と区切り文字 ---) を確認してください。`;
            }
        }

        function parseMergeInput(text) {
            const participantsData = text.split(/^\s*---\s*$/m); // Split by '---' line
            const allIntervals = [];
            const currentYear = referenceDateForWeek.getFullYear(); // Use year from displayed week

            for (const participantText of participantsData) {
                if (!participantText.trim()) continue; // Skip empty sections between '---'

                const lines = participantText.trim().split('\n');
                const participantIntervals = [];
                const lineRegex = /(\d{1,2}\/\d{1,2})\s+(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})/;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine || trimmedLine.startsWith('#') || trimmedLine.startsWith('//') || trimmedLine.startsWith('参加者')) continue;

                    const match = trimmedLine.match(lineRegex);
                    if (match) {
                        const dateStr = match[1];
                        const startTimeStr = match[2];
                        const endTimeStr = match[3];
                        const [month, day] = dateStr.split('/').map(Number);
                        const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                        const [endHour, endMinute] = endTimeStr.split(':').map(Number);

                        if ([month, day, startHour, startMinute, endHour, endMinute].some(isNaN)) {
                             console.warn("数値への変換に失敗:", trimmedLine); continue;
                         }

                        const startDate = new Date(currentYear, month - 1, day, startHour, startMinute);
                        let endDate = new Date(currentYear, month - 1, day, endHour, endMinute);

                        if (endDate <= startDate) { endDate.setDate(endDate.getDate() + 1); }
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                            console.warn("無効な日付オブジェクト:", trimmedLine); continue;
                        }
                        participantIntervals.push({ start: startDate, end: endDate });
                    } else {
                        console.warn("解析できない行 (無視します):", trimmedLine);
                    }
                }
                if (participantIntervals.length > 0) {
                    allIntervals.push(participantIntervals);
                }
            }
            return allIntervals;
        }


        function findOverlaps(participantsIntervals) {
             const numParticipants = participantsIntervals.length;
             if (numParticipants < 2) return [];

             const events = [];
             participantsIntervals.forEach(intervals => {
                 intervals.forEach(interval => {
                     if (interval.end > interval.start) {
                         events.push({ time: interval.start, type: 'start' });
                         events.push({ time: interval.end, type: 'end' });
                     }
                 });
             });

             events.sort((a, b) => {
                 const timeDiff = a.time.getTime() - b.time.getTime();
                 if (timeDiff !== 0) return timeDiff;
                 return a.type === 'start' ? -1 : 1; // start before end at same time
             });

             const commonIntervals = [];
             let overlapCount = 0;
             let overlapStartTime = null;

             for (let i = 0; i < events.length; ) { // Manual increment inside loop
                 const currentTime = events[i].time;
                 let timeSliceEnd = currentTime; // End of this time point processing

                 // Process all events at the exact same time
                 let countChangeAtThisTime = 0;
                 letstartIndex = i;
                 while (i < events.length && events[i].time.getTime() === currentTime.getTime()) {
                      if (events[i].type === 'start') {
                           countChangeAtThisTime++;
                      } else {
                           countChangeAtThisTime--;
                      }
                      i++; // Move to the next event
                 }
                 // The time for the next distinct event (if any)
                 if (i < events.length) {
                      timeSliceEnd = events[i].time;
                 }

                 const prevOverlapCount = overlapCount; // Count before applying changes at this time
                 overlapCount += countChangeAtThisTime; // Apply cumulative change

                 // Evaluate state change *after* processing all events at currentTime
                 // Overlap started? (Became N, was less than N before)
                 if (overlapCount === numParticipants && prevOverlapCount < numParticipants) {
                     overlapStartTime = currentTime;
                 }
                 // Overlap ended? (Was N, now less than N)
                 else if (overlapCount < numParticipants && prevOverlapCount === numParticipants) {
                     if (overlapStartTime !== null && currentTime > overlapStartTime) {
                         commonIntervals.push({ start: overlapStartTime, end: currentTime });
                     }
                     overlapStartTime = null;
                 }
                 // Special case: If an interval starts and ends exactly when count is N (point overlap)
                 // This is handled by the above logic, as count becomes N then immediately < N.

                 // If currently in overlap (count is N), and there's a time gap before the next event
                 if (overlapCount === numParticipants && overlapStartTime !== null && timeSliceEnd > currentTime) {
                    // The overlap continues until the next event time `timeSliceEnd`
                    // We record the segment when the overlap *ends* or when processing loop finishes
                 }

             } // End of event loop

             return commonIntervals;
         }


        function displayMergeResult(overlaps) {
            if (!overlaps || overlaps.length === 0) {
                mergeResultDiv.textContent = "全員が共通して空いている時間はありませんでした。";
                return;
            }
             // Merge adjacent/overlapping result blocks
             const mergedOverlaps = [];
             if (overlaps.length > 0) {
                 overlaps.sort((a, b) => a.start - b.start); // Ensure sorted
                 let currentMerged = { ...overlaps[0] };
                 for (let i = 1; i < overlaps.length; i++) {
                     const nextBlock = overlaps[i];
                     // Merge if next starts exactly or before current ends (handles potential overlaps from findOverlaps)
                     if (nextBlock.start.getTime() <= currentMerged.end.getTime()) {
                          // Extend the end time if the next block ends later
                         if (nextBlock.end > currentMerged.end) {
                             currentMerged.end = nextBlock.end;
                         }
                     } else {
                         mergedOverlaps.push(currentMerged);
                         currentMerged = { ...nextBlock };
                     }
                 }
                 mergedOverlaps.push(currentMerged); // Add the last block
             }
            const lines = mergedOverlaps.map(block => formatBlock(block));
            mergeResultDiv.textContent = lines.join('\n');
        }


        // --- 実行 ---
        initialize();

    </script>

</body>
</html>